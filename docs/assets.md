# Asset Management in Lightpack

This document outlines the common challenges in web asset management and how Lightpack approaches them with a pure PHP solution, without relying on Node.js or complex build tools.

## Common Challenges

### 1. Basic Asset Loading
**Problem:** Managing and loading different types of assets
- CSS files
- JavaScript files
- Images
- Fonts

**Pain Points:**
- Generating correct URLs
- Maintaining proper paths
- Handling different asset types
- Serving with correct headers

### 2. Cache Busting
**Problem:** Browser caching of outdated assets
- Files change but browsers serve cached versions
- Need to force reload when files update
- Cache invalidation strategies

**Pain Points:**
- When to invalidate cache
- How to version assets
- Maintaining cache headers
- Balancing cache vs fresh content

### 3. Development vs Production
**Problem:** Different needs for different environments
- Development needs quick feedback
- Production needs optimization
- Different serving strategies

**Pain Points:**
- Fast development cycle
- Production optimization
- Environment-specific configs
- Switching between environments

### 4. Asset Organization
**Problem:** Managing multiple assets efficiently
- Multiple CSS files
- Multiple JS files
- Page-specific assets
- Shared assets

**Pain Points:**
- Organizing assets logically
- Managing dependencies
- Loading order
- Code splitting

### 5. Module Dependencies
**Problem:** Managing JavaScript module dependencies
- Files depending on other files
- Loading order matters
- Mix of local and CDN files

**Pain Points:**
- Dependency management
- Module resolution
- Avoiding Node.js
- Browser compatibility

### 6. Performance
**Problem:** Optimizing asset delivery
- Multiple HTTP requests
- Large file sizes
- Slow loading times
- Browser limitations

**Pain Points:**
- Reducing requests
- File size optimization
- Loading strategies
- HTTP/2 optimization

## Solution Overview

### 1. Basic Asset Loading
We'll implement a simple but powerful asset loading system that:
- Uses a clean helper function: `asset('path/to/file')`
- Automatically determines correct MIME types
- Sets proper HTTP headers
- Supports different base URLs (local, CDN)
- Handles missing files gracefully

Example:
```php
// In views
<link href="<?= asset('css/app.css') ?>" rel="stylesheet">
<script src="<?= asset('js/app.js') ?>"></script>
<img src="<?= asset('img/logo.png') ?>">
```

### 2. Versioning Support
Instead of complex bundling, we'll use:
- File modification time as version
- Query string versioning (?v=timestamp)
- HTTP caching headers
- ETag support

This means:
- No build step needed
- Files cache until they change
- Easy to debug (clear file paths)
- HTTP/2 friendly

### 3. Environment Strategies
We'll implement environment-specific behaviors:
- Development:
  * No caching
  * Source maps
  * Clear file paths
  * Helpful error messages

- Production:
  * Aggressive caching
  * Versioned URLs
  * CDN support
  * Optimized headers

### 4. Asset Organization
We'll provide a simple but flexible organization system:
- Collections (group related assets)
- Page-specific assets
- Shared/common assets
- Clear loading order

Example:
```php
// Define collections
assets()->collection('admin', [
    'css/admin.css',
    'js/admin.js'
]);

// In views
<?= assets()->load('admin') ?>
```

### 5. Module Dependencies
We'll use modern browser features:
- Native ES modules
- Import maps for dependencies
- CDN fallbacks
- No bundling required

Example:
```html
<!-- Generated by Lightpack -->
<script type="importmap">
{
    "imports": {
        "alpine": "/js/alpine.js",
        "htmx": "https://unpkg.com/htmx.org"
    }
}
</script>
```

### 6. Performance Optimization
We'll leverage HTTP/2 features:
- Server Push for critical assets
- Proper cache headers
- Content-encoding
- Preload hints

Plus:
- Basic minification when needed
- Automatic compression
- Smart loading order
- Browser hints

The key advantages of this approach:
1. No Node.js or npm needed
2. Works out of the box
3. Easy to understand
4. Easy to debug
5. Production ready
6. HTTP/2 optimized

Each solution focuses on solving real problems without adding unnecessary complexity. We let modern browsers do what they're good at and only add PHP-based optimizations where they make sense.

## Lightpack's Approach

Our solution focuses on:
1. Pure PHP implementation
2. No Node.js dependency
3. HTTP/2 optimization
4. Simple but effective
5. Development friendly
6. Production ready

We achieve this by:
- Leveraging modern browser features
- Using HTTP/2 capabilities
- Simple versioning strategy
- Clear organization patterns
- Smart serving strategies

## Next Steps

1. Implement basic asset loading
2. Add versioning support
3. Develop environment strategies
4. Create organization structure
5. Handle module dependencies
6. Optimize performance

Each step will be implemented in pure PHP, following Lightpack's philosophy of simplicity and effectiveness.

## Future Implementations

### 1. Environment-specific Features
- Development mode with no caching
- Production mode with aggressive caching
- Different error handling per environment
- Source map handling

### 2. Performance Optimizations
- Basic CSS/JS minification (optional, keeping it simple)
- Gzip/Brotli compression headers
- Advanced HTTP/2 features
- Browser cache control headers

### 3. CLI Commands
```bash
php lightpack asset:list        # List all registered assets
php lightpack asset:verify      # Check if all assets exist
php lightpack asset:clean-cache # Clean asset cache
php lightpack asset:generate-sri # Generate SRI hashes for files
```

### 4. Asset Discovery
- Auto-discover assets in directories
- Pattern matching for collections
- Auto-grouping by type
- Manifest file generation

### 5. Error Handling & Debugging
- Missing asset detection
- Invalid path warnings
- Detailed error messages in dev
- Asset load timing info

Each of these features will maintain Lightpack's philosophy:
- Pure PHP implementation
- No external dependencies
- Simple but effective
- HTTP/2 optimized
- Development friendly

## Comprehensive Documentation for the Asset Feature with Practical Examples

### Basic Usage

#### 1. Loading Single Assets

```php
// In your view files
<link href="<?= assets()->url('css/app.css') ?>" rel="stylesheet">
<script src="<?= assets()->url('js/app.js') ?>"></script>
<img src="<?= assets()->url('img/logo.png') ?>" alt="Logo">
```

The `url()` method:
- Generates correct URLs with proper base path
- Adds version query string for cache busting
- Supports both local and CDN paths
- Handles missing files gracefully

#### 2. Helper Methods for Common Assets

```php
// CSS files - adds <link> tag with proper attributes
<?= assets()->css('app.css') ?>
<?= assets()->css(['base.css', 'app.css']) ?>

// JavaScript files - adds <script> tag with defer
<?= assets()->js('app.js') ?>
<?= assets()->js(['vendor.js', 'app.js']) ?>

// Images - adds <img> tag with proper attributes
<?= assets()->img('logo.png', ['alt' => 'Logo', 'class' => 'header-logo']) ?>
```

### Asset Collections

Collections help organize and load related assets together.

```php
// Define collections in your service provider or bootstrap
assets()->collection('admin', [
    'css/admin/base.css',
    'css/admin/dashboard.css',
    'js/admin/core.js',
    'js/admin/dashboard.js',
]);

// In your admin layout
<?= assets()->loadCollection('admin') ?>

// Define multiple collections
assets()->collection('frontend', [
    'css/app.css',
    'js/app.js',
]);

assets()->collection('charts', [
    'css/charts.css',
    'js/charts.js',
]);

// Load multiple collections
<?= assets()->loadCollection(['frontend', 'charts']) ?>
```

### Versioning & Cache Busting

Lightpack provides automatic versioning for assets:

```php
// Generates: /css/app.css?v=1712847728
echo assets()->url('css/app.css');

// Disable versioning for specific files
echo assets()->url('css/app.css', ['version' => false]);

// Version manifest for production
// In config/assets.php
return [
    'manifest' => [
        'enabled' => true,
        'path' => 'versions.json',
        'directories' => ['css', 'js', 'fonts', 'img'],
    ],
];

// Generated versions.json
{
    "css/app.css": "1712847728",
    "js/app.js": "1712847729"
}
```

### HTTP/2 Optimization

#### 1. Preloading Critical Assets

```php
// In your filter or service provider
assets()->preload([
    // Critical CSS for above-the-fold content
    'css/critical.css',
    
    // Essential fonts
    'fonts/roboto-regular.woff2',
    
    // Core JavaScript
    'js/app.js',
]);

// Generate preload headers
assets()->sendPreloadHeaders();
```

#### 2. Resource Hints

```php
// In your BeforeFilter
class AssetFilter extends Filter 
{
    public function before(Request $request) 
    {
        // DNS prefetch for external resources
        assets()->dnsPreconnect('https://api.example.com');

        // Preconnect to origins
        assets()->preconnect('https://cdn.example.com');

        // Prefetch future resources
        assets()->prefetch('js/comments.js');
    }
}
```

#### 3. Dynamic Preloading

```php
// In your filter
class AdminAssetsFilter extends Filter 
{
    public function before(Request $request) 
    {
        if ($request->route()->hasPrefix('admin')) {
            assets()->preload([
                'css/admin.css',
                'js/admin/core.js',
            ]);
        }

        if ($request->user()->can('view-charts')) {
            assets()->preload('js/modules/charts.js');
        }
    }
}
```

#### 4. Module Preloading

```php
// Preload ES modules and dependencies
assets()->preloadModule('js/app.js');

// Preload specific module features
assets()->preloadModule([
    'js/features/comments.js',
    'js/features/search.js',
]);

// With import map support
assets()->importMap([
    'imports' => [
        'app' => '/js/app.js',
        'features' => '/js/features.js',
    ],
]);
assets()->preloadModule('features');
```

#### 5. Conditional Preloading

```php
// In your filter
class ResponsiveAssetsFilter extends Filter 
{
    public function before(Request $request) 
    {
        // Preload based on device/browser capabilities
        if ($request->isMobile()) {
            assets()->preload('css/mobile.css');
        } else {
            assets()->preload('css/desktop.css');
        }

        // Preload based on feature flags
        if (get_env('FEATURE_NEW_EDITOR')) {
            assets()->preload('js/new-editor.js');
        }
    }
}
```

### Configuration Updates

```php
// config/assets.php
return [
    'manifest' => [
        // Enable version manifest in production
        'enabled' => get_env('APP_ENV') === 'production',
        
        // Path to store version manifest
        'path' => 'versions.json',
        
        // Directories to track for versions
        'directories' => [
            'css',
            'js',
            'fonts',
            'img',
        ],
    ],
    
    // Preload configuration
    'preload' => [
        // Default preload strategy
        'strategy' => 'critical',
        
        // Always preload these assets
        'critical' => [
            'css/app.css',
            'js/app.js',
            'fonts/roboto-regular.woff2',
        ],
        
        // Resource hints
        'hints' => [
            'dns-prefetch' => [
                'https://api.example.com',
            ],
            'preconnect' => [
                'https://cdn.example.com',
            ],
        ],
    ],
];

// Set environment variables
set_env('ASSET_URL', 'https://cdn.example.com');
set_env('APP_ENV', 'production');

// Get environment variables
$assetUrl = get_env('ASSET_URL');
$isProd = get_env('APP_ENV') === 'production';
```

### Best Practices

1. **Organize Assets Logically**
```
public/
  ├── css/
  │   ├── app.css
  │   └── admin/
  │       └── dashboard.css
  ├── js/
  │   ├── app.js
  │   └── modules/
  │       └── chart.js
  ├── img/
  │   └── logo.png
  └── fonts/
      └── roboto.woff2
```

2. **Use Collections for Related Assets**
```php
// Group admin assets
assets()->collection('admin', [
    'css/admin/base.css',
    'css/admin/forms.css',
    'js/admin/core.js',
]);

// Group chart assets
assets()->collection('charts', [
    'css/charts/base.css',
    'js/modules/charts.js',
]);
```

3. **Preload Critical Assets**
```php
// In your service provider or middleware
assets()->preload([
    'css/critical.css',
    'fonts/roboto.woff2',
]);
```

4. **Use Import Maps for JavaScript Dependencies**
```php
// Define clear module paths
assets()->importMap([
    'imports' => [
        'app' => '/js/app.js',
        'components' => '/js/components.js',
        'alpine' => '/js/vendor/alpine.js',
    ],
]);
```

5. **Version Control in Production**
```php
// Generate version manifest
php cli asset:versions

// Assets automatically use versions from manifest
echo assets()->url('css/app.css');
// Output: /css/app.css?v=1712847728
```

### Advanced Usage

#### 1. Conditional Asset Loading

```php
// Load assets based on conditions
if ($user->isAdmin()) {
    assets()->loadCollection('admin');
}

if ($page->hasCharts()) {
    assets()->loadCollection('charts');
}
```

#### 2. Custom Attributes

```php
// Add custom attributes to assets
echo assets()->css('app.css', ['media' => 'print']);
echo assets()->js('app.js', ['async' => true]);
echo assets()->img('logo.png', ['loading' => 'lazy']);
```

### Security Considerations

1. **Always validate file paths**
```php
// Asset class automatically:
// - Sanitizes file paths
// - Prevents directory traversal
// - Checks for valid file types
```

2. **Use environment variables**
```env
# Keep asset URLs configurable
ASSET_URL=https://cdn.example.com
```

3. **Version assets in production**
```php
// Enable version manifest
'manifest' => [
    'enabled' => get_env('APP_ENV') === 'production',
],
```

### Performance Tips

1. **Use collections to organize assets**
2. **Preload critical assets**
3. **Enable version manifest in production**
4. **Use import maps for JavaScript modules**
5. **Leverage HTTP/2 features**

### Migration Guide

If you're using the old `Url::asset()` method, migrate to the new Asset class:

```php
// Old way (still works but no versioning)
echo Url::asset('css/app.css');

// New way (recommended)
echo assets()->url('css/app.css');  // Adds version
echo assets()->css('app.css');      // Adds <link> tag
```

### Troubleshooting

1. **Assets not loading?**
   - Check file paths are relative to public directory
   - Verify ASSET_URL or APP_URL environment variables
   - Check file permissions

2. **Versions not updating?**
   - Regenerate version manifest
   - Clear browser cache
   - Check manifest configuration

3. **Import maps not working?**
   - Ensure browser supports import maps
   - Check module paths are correct
   - Verify JavaScript files are modules

### CLI Commands

```bash
# Generate version manifest
php cli asset:versions

# Clear asset cache
php cli asset:clear
