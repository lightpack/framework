# Asset Management in Lightpack

This document outlines the common challenges in web asset management and how Lightpack approaches them with a pure PHP solution, without relying on Node.js or complex build tools.

## Common Challenges

### 1. Basic Asset Loading
**Problem:** Managing and loading different types of assets
- CSS files
- JavaScript files
- Images
- Fonts

**Pain Points:**
- Generating correct URLs
- Maintaining proper paths
- Handling different asset types
- Serving with correct headers

### 2. Cache Busting
**Problem:** Browser caching of outdated assets
- Files change but browsers serve cached versions
- Need to force reload when files update
- Cache invalidation strategies

**Pain Points:**
- When to invalidate cache
- How to version assets
- Maintaining cache headers
- Balancing cache vs fresh content

### 3. Development vs Production
**Problem:** Different needs for different environments
- Development needs quick feedback
- Production needs optimization
- Different serving strategies

**Pain Points:**
- Fast development cycle
- Production optimization
- Environment-specific configs
- Switching between environments

### 4. Asset Organization
**Problem:** Managing multiple assets efficiently
- Multiple CSS files
- Multiple JS files
- Page-specific assets
- Shared assets

**Pain Points:**
- Organizing assets logically
- Managing dependencies
- Loading order
- Code splitting

### 5. Module Dependencies
**Problem:** Managing JavaScript module dependencies
- Files depending on other files
- Loading order matters
- Mix of local and CDN files

**Pain Points:**
- Dependency management
- Module resolution
- Avoiding Node.js
- Browser compatibility

### 6. Performance
**Problem:** Optimizing asset delivery
- Multiple HTTP requests
- Large file sizes
- Slow loading times
- Browser limitations

**Pain Points:**
- Reducing requests
- File size optimization
- Loading strategies
- HTTP/2 optimization

## Solution Overview

### 1. Basic Asset Loading
We'll implement a simple but powerful asset loading system that:
- Uses a clean helper function: `asset('path/to/file')`
- Automatically determines correct MIME types
- Sets proper HTTP headers
- Supports different base URLs (local, CDN)
- Handles missing files gracefully

Example:
```php
// In views
<link href="<?= asset('css/app.css') ?>" rel="stylesheet">
<script src="<?= asset('js/app.js') ?>"></script>
<img src="<?= asset('img/logo.png') ?>">
```

### 2. Versioning Support
Instead of complex bundling, we'll use:
- File modification time as version
- Query string versioning (?v=timestamp)
- HTTP caching headers
- ETag support

This means:
- No build step needed
- Files cache until they change
- Easy to debug (clear file paths)
- HTTP/2 friendly

### 3. Environment Strategies
We'll implement environment-specific behaviors:
- Development:
  * No caching
  * Source maps
  * Clear file paths
  * Helpful error messages

- Production:
  * Aggressive caching
  * Versioned URLs
  * CDN support
  * Optimized headers

### 4. Asset Organization
We'll provide a simple but flexible organization system:
- Collections (group related assets)
- Page-specific assets
- Shared/common assets
- Clear loading order

Example:
```php
// Define collections
assets()->collection('admin', [
    'css/admin.css',
    'js/admin.js'
]);

// In views
<?= assets()->load('admin') ?>
```

### 5. Module Dependencies
We'll use modern browser features:
- Native ES modules
- Import maps for dependencies
- CDN fallbacks
- No bundling required

Example:
```html
<!-- Generated by Lightpack -->
<script type="importmap">
{
    "imports": {
        "alpine": "/js/alpine.js",
        "htmx": "https://unpkg.com/htmx.org"
    }
}
</script>
```

### 6. Performance Optimization
We'll leverage HTTP/2 features:
- Server Push for critical assets
- Proper cache headers
- Content-encoding
- Preload hints

Plus:
- Basic minification when needed
- Automatic compression
- Smart loading order
- Browser hints

The key advantages of this approach:
1. No Node.js or npm needed
2. Works out of the box
3. Easy to understand
4. Easy to debug
5. Production ready
6. HTTP/2 optimized

Each solution focuses on solving real problems without adding unnecessary complexity. We let modern browsers do what they're good at and only add PHP-based optimizations where they make sense.

## Lightpack's Approach

Our solution focuses on:
1. Pure PHP implementation
2. No Node.js dependency
3. HTTP/2 optimization
4. Simple but effective
5. Development friendly
6. Production ready

We achieve this by:
- Leveraging modern browser features
- Using HTTP/2 capabilities
- Simple versioning strategy
- Clear organization patterns
- Smart serving strategies

## Next Steps

1. Implement basic asset loading
2. Add versioning support
3. Develop environment strategies
4. Create organization structure
5. Handle module dependencies
6. Optimize performance

Each step will be implemented in pure PHP, following Lightpack's philosophy of simplicity and effectiveness.
